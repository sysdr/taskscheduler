package com.ultrascale.scheduler.demo.service;

import com.ultrascale.scheduler.demo.model.TaskExecutionRecord;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import java.time.LocalDateTime;
import java.util.concurrent.atomic.AtomicLong;

@Service
public class ProblematicScheduledService {
    
    private static final Logger logger = LoggerFactory.getLogger(ProblematicScheduledService.class);
    
    @Autowired
    private TaskExecutionRepository taskExecutionRepository;
    
    @Value("${app.instance.id:UNKNOWN}")
    private String instanceId;
    
    private final AtomicLong executionCounter = new AtomicLong(0);
    
    /**
     * Daily Report Generation - PROBLEMATIC in distributed environment
     * This task should run once per day across all instances, but will run
     * once per day PER INSTANCE, causing duplicate reports
     */
    @Scheduled(cron = "0 */2 * * * *") // Every 2 minutes for demo purposes
    public void generateDailyReport() {
        long executionNumber = executionCounter.incrementAndGet();
        LocalDateTime now = LocalDateTime.now();
        
        logger.error("üö® DUPLICATE ALERT: Instance {} executing generateDailyReport (execution #{})", 
                    instanceId, executionNumber);
        
        // Simulate report generation work
        try {
            Thread.sleep(1000); // Simulate processing time
            
            // Record this execution in database
            TaskExecutionRecord record = new TaskExecutionRecord(
                "DAILY_REPORT_GENERATION", 
                instanceId, 
                now, 
                "COMPLETED",
                "Generated daily sales report with 1,000 records processed"
            );
            taskExecutionRepository.save(record);
            
            logger.error("üìä Report Generated by instance {}: Processing 1,000 customer records", instanceId);
            
        } catch (Exception e) {
            TaskExecutionRecord record = new TaskExecutionRecord(
                "DAILY_REPORT_GENERATION", 
                instanceId, 
                now, 
                "FAILED",
                "Error: " + e.getMessage()
            );
            taskExecutionRepository.save(record);
            logger.error("‚ùå Report generation failed on instance {}: {}", instanceId, e.getMessage());
        }
    }
    
    /**
     * Billing Process - CRITICAL PROBLEM in distributed environment
     * Multiple instances will process the same billing data, potentially
     * charging customers multiple times
     */
    @Scheduled(fixedRate = 90000) // Every 1.5 minutes for demo
    public void processBilling() {
        LocalDateTime now = LocalDateTime.now();
        
        logger.error("üí∞ BILLING ALERT: Instance {} processing customer billing", instanceId);
        
        try {
            // Simulate billing processing
            Thread.sleep(500);
            
            TaskExecutionRecord record = new TaskExecutionRecord(
                "CUSTOMER_BILLING", 
                instanceId, 
                now, 
                "COMPLETED",
                "Processed billing for 500 customers - $125,000 total"
            );
            taskExecutionRepository.save(record);
            
            logger.error("üí≥ Billing Processed by instance {}: 500 customers charged", instanceId);
            
        } catch (Exception e) {
            TaskExecutionRecord record = new TaskExecutionRecord(
                "CUSTOMER_BILLING", 
                instanceId, 
                now, 
                "FAILED",
                "Billing error: " + e.getMessage()
            );
            taskExecutionRepository.save(record);
        }
    }
    
    /**
     * Data Cleanup - Another problematic scenario
     * Multiple instances cleaning the same data can cause race conditions
     */
    @Scheduled(fixedDelay = 120000) // Every 2 minutes after completion
    public void cleanupExpiredData() {
        LocalDateTime now = LocalDateTime.now();
        
        logger.error("üßπ CLEANUP ALERT: Instance {} cleaning expired data", instanceId);
        
        try {
            Thread.sleep(800); // Simulate cleanup work
            
            int recordsDeleted = (int) (Math.random() * 100 + 50); // Simulate variable cleanup
            
            TaskExecutionRecord record = new TaskExecutionRecord(
                "DATA_CLEANUP", 
                instanceId, 
                now, 
                "COMPLETED",
                "Deleted " + recordsDeleted + " expired records"
            );
            taskExecutionRepository.save(record);
            
            logger.error("üóëÔ∏è Cleanup by instance {}: {} expired records deleted", instanceId, recordsDeleted);
            
        } catch (Exception e) {
            TaskExecutionRecord record = new TaskExecutionRecord(
                "DATA_CLEANUP", 
                instanceId, 
                now, 
                "FAILED",
                "Cleanup error: " + e.getMessage()
            );
            taskExecutionRepository.save(record);
        }
    }
}
